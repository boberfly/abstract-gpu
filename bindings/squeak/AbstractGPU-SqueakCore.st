SystemOrganization addCategory: #'AbstractGPU-SqueakCore'!ExternalStructure subclass: #AGPUExternalStructure	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AbstractGPU-SqueakCore'!AGPUExternalStructure class	instanceVariableNames: 'structureByteAlignment'!AGPUExternalStructure class	instanceVariableNames: 'structureByteAlignment'!!AGPUExternalStructure class methodsFor: 'as yet unclassified' stamp: 'rsf 5/4/2019 23:13'!alignmentForType: externalType	externalType isPointerType ifFalse: [		(externalType referentClass ~~ nil and: [externalType referentClass inheritsFrom: AGPUExternalStructure]) ifTrue: [			^ externalType referentClass byteAlignment		].	].	^ externalType byteSize! !!AGPUExternalStructure class methodsFor: 'as yet unclassified' stamp: 'rsf 5/4/2019 23:15'!byteAlignment	structureByteAlignment ifNil: [self defineFields].	self assert: structureByteAlignment ~~ nil.	^ structureByteAlignment! !!AGPUExternalStructure class methodsFor: 'as yet unclassified' stamp: 'rsf 5/4/2019 23:14'!compileFields: specArray withAccessors: aSymbol 	"Compile a type specification for the FFI machinery.	Return the newly compiled spec.	Eventually generate the field accessors according to following rules:	- aSymbol = #always always generate the accessors	- aSymbol = #never never generate the accessors	- aSymbol = #generated only generate the auto-generated accessors	- aSymbol = #absent only generate the absent accessors"	| byteOffset byteAlignment typeSpec newCompiledSpec |	(specArray size > 0 and: [specArray first class ~~ Array]) ifTrue:		[^ self compileAlias: specArray withAccessors: aSymbol].	byteOffset := 0.	byteAlignment := 1.	typeSpec := WriteStream on: (WordArray new: 10).	typeSpec nextPut: FFIFlagStructure.	"dummy for size"	specArray do:		[:spec | | fieldName fieldType isPointerField externalType typeSize typeAlignment selfRefering |		fieldName := spec first.		fieldType := spec second.		isPointerField := fieldType last = $*.		fieldType := (fieldType findTokens: ' *') first.		externalType := ExternalType atomicTypeNamed: fieldType.		selfRefering := isPointerField and: [externalType isNil and: [fieldType = self asString]].		selfRefering ifTrue: [			externalType := ExternalType void asPointerType		] ifFalse:[			externalType == nil ifTrue: ["non-atomic"				Symbol					hasInterned: fieldType					ifTrue: [:sym | externalType := ExternalType structTypeNamed: sym].			].			externalType == nil ifTrue:[				Transcript show: '(' , fieldType , ' is void)'.				externalType := ExternalType void.			].			isPointerField ifTrue: [externalType := externalType asPointerType: self pointerSize]].			typeSize := externalType byteSize..			typeAlignment := self alignmentForType: externalType.			byteOffset := byteOffset alignedTo: typeAlignment.			byteAlignment := byteAlignment max: typeAlignment.			(fieldName notNil and: [self shouldGenerate: fieldName policy: aSymbol]) ifTrue: [				self defineFieldAccessorsFor: fieldName startingAt: byteOffset + 1 type: externalType.			].			typeSpec nextPutAll: (externalType embeddedSpecWithSize: typeSize).			byteOffset := byteOffset + typeSize.		].	structureByteAlignment := byteAlignment.	newCompiledSpec := typeSpec contents.	newCompiledSpec at: 1 put: ((byteOffset alignedTo: byteAlignment) bitOr: FFIFlagStructure).	^ newCompiledSpec! !AGPUExternalStructure subclass: #AGPUExternalUnion	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AbstractGPU-SqueakCore'!!AGPUExternalUnion class methodsFor: 'as yet unclassified' stamp: 'rsf 5/4/2019 23:18'!compileFields: specArray withAccessors: aSymbol 	"Compile a type specification for the FFI machinery.	Return the newly compiled spec.	Eventually generate the field accessors according to following rules:	- aSymbol = #always always generate the accessors	- aSymbol = #never never generate the accessors	- aSymbol = #generated only generate the auto-generated accessors	- aSymbol = #absent only generate the absent accessors"	| byteSize byteAlignment typeSpec newCompiledSpec |	(specArray size > 0 and: [specArray first class ~~ Array]) ifTrue:		[^ self compileAlias: specArray withAccessors: aSymbol].	byteSize := 0.	byteAlignment := 1.	typeSpec := WriteStream on: (WordArray new: 10).	typeSpec nextPut: FFIFlagStructure.	"dummy for size"	specArray do:		[:spec | | fieldName fieldType isPointerField externalType typeSize typeAlignment selfRefering |		fieldName := spec first.		fieldType := spec second.		isPointerField := fieldType last = $*.		fieldType := (fieldType findTokens: ' *') first.		externalType := ExternalType atomicTypeNamed: fieldType.		selfRefering := isPointerField and: [externalType isNil and: [fieldType = self asString]].		selfRefering ifTrue: [			externalType := ExternalType void asPointerType		] ifFalse:[			externalType == nil ifTrue: ["non-atomic"				Symbol					hasInterned: fieldType					ifTrue: [:sym | externalType := ExternalType structTypeNamed: sym].			].			externalType == nil ifTrue:[				Transcript show: '(' , fieldType , ' is void)'.				externalType := ExternalType void.			].			isPointerField ifTrue: [externalType := externalType asPointerType: self pointerSize]].			typeSize := externalType byteSize..			typeAlignment := self alignmentForType: externalType.			byteAlignment := byteAlignment max: typeAlignment.			(fieldName notNil and: [self shouldGenerate: fieldName policy: aSymbol]) ifTrue: [				self defineFieldAccessorsFor: fieldName startingAt: 1 type: externalType.			].			typeSpec nextPutAll: (externalType embeddedSpecWithSize: typeSize).			byteSize := byteSize max: typeSize.		].	structureByteAlignment := byteAlignment.	newCompiledSpec := typeSpec contents.	newCompiledSpec at: 1 put: ((byteSize alignedTo: byteAlignment) bitOr: FFIFlagStructure).	^ newCompiledSpec! !Object subclass: #AGPUBindingsCommon	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AbstractGPU-SqueakCore'!AGPUBindingsCommon subclass: #AGPU	instanceVariableNames: 'session mainPlatform mainDevice'	classVariableNames: 'UniqueInstance UniqueSessionObject'	poolDictionaries: ''	category: 'AbstractGPU-SqueakCore'!!AGPU class methodsFor: 'platform querying' stamp: ''!firstPlatform	^ self uniqueInstance firstPlatform! !!AGPU class methodsFor: 'platform querying' stamp: 'rsf 5/4/2019 22:03'!initialize	"AGPU initialize"	Smalltalk addToStartUpList: self.	Smalltalk addToShutDownList: self.! !!AGPU class methodsFor: 'main device' stamp: ''!mainDevice	^ self uniqueInstance mainDevice! !!AGPU class methodsFor: 'main device' stamp: ''!mainPlatform	^ self uniqueInstance mainPlatform! !!AGPU class methodsFor: 'platform querying' stamp: ''!platforms	^ self uniqueInstance platforms! !!AGPU class methodsFor: 'as yet unclassified' stamp: 'rsf 5/4/2019 22:01'!session	^ UniqueSessionObject ifNil: [ UniqueSessionObject := Object new ]! !!AGPU class methodsFor: 'platform querying' stamp: 'rsf 5/4/2019 22:03'!startUp	UniqueSessionObject := Object new.! !!AGPU class methodsFor: 'platform querying' stamp: ''!uniqueInstance	UniqueInstance ifNil: [ UniqueInstance := self new. ].	^ UniqueInstance! !!AGPU methodsFor: 'main device' stamp: 'rsf 5/4/2019 22:06'!checkSession	(session ~~ AGPU session or: [mainDevice isNil]) ifTrue: [		self openMainDevice.		session := AGPU session.	].! !!AGPU methodsFor: 'main device' stamp: ''!debugLayerEnabled	^ true! !!AGPU methodsFor: 'platform querying' stamp: ''!firstPlatform	^ self platforms first! !!AGPU methodsFor: 'main device' stamp: ''!mainDevice	self checkSession.	^ mainDevice! !!AGPU methodsFor: 'main device' stamp: ''!mainPlatform	self checkSession.	^ mainPlatform! !!AGPU methodsFor: 'main device' stamp: ''!openMainDevice	| deviceOpenInfo |	mainPlatform := self firstPlatform.	mainPlatform ifNil: [ self error: 'No AGPU platform is available.' ].		deviceOpenInfo := AGPUDeviceOpenInfo new debug_layer: self debugLayerEnabled asBit.	mainDevice := mainPlatform openDevice: deviceOpenInfo.	mainDevice ifNil: [ self error: 'Failed to open the main AGPU device' ].	! !!AGPU methodsFor: 'platform querying' stamp: ''!platformCount	| platformCount |	platformCount := ExternalAddress allocate: 4.	[ 		self getPlatforms: 0 platforms: nil ret_numplatforms: platformCount.		^ platformCount unsignedLongAt: 1 	] ensure: [ platformCount free ].! !!AGPU methodsFor: 'platform querying' stamp: ''!platforms	| platformCount platformPointers platformCountRet pointerSize |	platformCount := self platformCount.	platformCountRet := ExternalAddress allocate: 4.	[ 		pointerSize := Smalltalk wordSize.		platformPointers := ExternalAddress allocate: pointerSize * platformCount.		[			self getPlatforms: platformCount platforms: platformPointers ret_numplatforms: platformCountRet.			platformCount := platformCountRet unsignedLongAt: 1.			^ (1 to: platformCount) collect: [ :i | (Smalltalk at: #AGPUPlatform) forManualHandle: (platformPointers pointerAt: (i-1)*pointerSize + 1)]		] ensure: [ platformPointers free ]	] ensure: [ platformCountRet free ].! !!AGPUBindingsCommon class methodsFor: 'as yet unclassified' stamp: ''!checkErrorCode: errorCode	errorCode < 0 ifTrue: [ 		self error: 'Got an error from AGPU.'	]! !!AGPUBindingsCommon class methodsFor: 'accessing' stamp: ''!validHandleOf: anObject	^ anObject ifNil: [ ExternalAddress null ] ifNotNil: [ anObject validHandle ]! !!AGPUBindingsCommon methodsFor: 'error checking' stamp: ''!checkErrorCode: errorCode	errorCode < 0 ifTrue: [ 		Transcript show: 'Got an error from AGPU: ' , errorCode printString; cr.		self error: 'Got an error from AGPU.'	]! !!AGPUBindingsCommon methodsFor: 'freeing resources' stamp: ''!release	self primitiveRelease.! !!AGPUBindingsCommon methodsFor: 'accessing' stamp: ''!validHandleOf: anObject	^ anObject ifNotNil: [ anObject validHandle ]! !AGPUBindingsCommon subclass: #AGPUInterface	instanceVariableNames: 'handle'	classVariableNames: ''	poolDictionaries: ''	category: 'AbstractGPU-SqueakCore'!!AGPUInterface class methodsFor: 'instance creation' stamp: ''!forHandle: aHandle	(aHandle isNil or: [ aHandle isNull ]) ifTrue: [ ^ nil ].	^ self new handle: aHandle; autoRelease; yourself! !!AGPUInterface class methodsFor: 'instance creation' stamp: ''!forManualHandle: aHandle	^ self new handle: aHandle! !!AGPUInterface methodsFor: 'finalization' stamp: ''!autoRelease	^ self class finalizationRegistry add: self! !!AGPUInterface methodsFor: 'accessing' stamp: 'rsf 5/4/2019 23:21'!finalize	(handle ~~ nil and: [ handle isNull not ]) ifTrue: [		self primitiveRelease	]	! !!AGPUInterface methodsFor: 'accessing' stamp: ''!handle	^ handle! !!AGPUInterface methodsFor: 'accessing' stamp: ''!handle: aHandle	handle := aHandle! !!AGPUInterface methodsFor: 'testing' stamp: ''!isNull	^ handle isNil or: [ handle isNull ]! !!AGPUInterface methodsFor: 'finalization' stamp: ''!release	self class finalizationRegistry remove: self.	self primitiveRelease.	handle := nil.! !!AGPUInterface methodsFor: 'accessing' stamp: ''!validHandle	handle ifNil: [ self error: 'Trying to use an object with an invalid handle.' ].	^ handle! !ExternalLibrary subclass: #AGPUCBindingsBase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AbstractGPU-SqueakCore'!AGPUCBindingsBase class	instanceVariableNames: 'uniqueInstance'!AGPUCBindingsBase class	instanceVariableNames: 'uniqueInstance'!!AGPUCBindingsBase class methodsFor: 'as yet unclassified' stamp: 'rsf 5/4/2019 19:05'!moduleName	^ 'Agpu'! !!AGPUCBindingsBase class methodsFor: 'as yet unclassified' stamp: 'rsf 5/4/2019 19:11'!uniqueInstance	^ uniqueInstance ifNil: [uniqueInstance := self new]! !AGPU initialize!